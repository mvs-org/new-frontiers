(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{364:function(e,t,n){"use strict";n.r(t);var r=n(42),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"remote-procedure-calls"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remote-procedure-calls"}},[e._v("#")]),e._v(" Remote Procedure Calls")]),e._v(" "),n("p",[e._v("Remote Procedure Calls, or RPCs, are a way for an external program (eg.\na frontend) to communicate with a node. They are used for checking\nstorage values, submitting transactions, and querying the current\nconsensus authorities with any client that speaks json RPC. One widely\navailable option for using RPC is curl.")]),e._v(" "),n("p",[e._v("Example:")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[e._v("curl")]),e._v(" -H "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Content-Type: application/json"')]),e._v(" -d "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'{"id":"1",\n"jsonrpc":"2.0", "method":"state\\_getRuntimeVersion", "params":\\[\\]}\'')]),e._v("\nhttps://vm.mvs.org/mainnet_rpc\n")])])]),n("p",[e._v("List of calls: * calls marked with an asterix are under development *")]),e._v(" "),n("p",[n("strong",[e._v("account_nextIndex")]),e._v(" ("),n("em",[e._v("account: AccountId)")]),n("br"),e._v("\nReturns the next valid index (aka nonce) for given account.\nThis method takes into consideration all pending transactions currently\nin the pool and if no transactions are found in the pool it fallbacks\nto query the index from the runtime (aka. state nonce).")]),e._v(" "),n("p",[n("strong",[e._v("author_hasKey")]),e._v(" ("),n("em",[e._v("public_key: Bytes,"),n("br"),e._v("\nkey_type: String")]),e._v(")"),n("br"),e._v("\nChecks if the keystore has private keys for the given public key and\nkey type. Returns `true` if a private key could be found.")]),e._v(" "),n("p",[n("strong",[e._v("author_hasSessionKeys")]),e._v(" ("),n("em",[e._v("session_keys: Bytes")]),e._v(") "),n("br"),e._v("\nChecks if the keystore has private keys for the given session public\nkeys. `session_keys` is the SCALE encoded session keys object from\ntheruntime. Returns `true` iff all private keys could be found.")]),e._v(" "),n("p",[n("strong",[e._v("author_insertKey")]),e._v(" ("),n("em",[e._v("key_type: String,suri: String,"),n("br"),e._v("\npublic: Bytes")]),e._v(")"),n("br"),e._v("\nInsert a key into the keystore.")]),e._v(" "),n("p",[n("strong",[e._v("author_pendingExtrinsics")]),e._v(" ()"),n("br"),e._v("\nReturns all pending extrinsics, potentially grouped by sender.")]),e._v(" "),n("p",[n("strong",[e._v("author_removeExtrinsic")]),e._v(" ("),n("em",[e._v("bytes_or_hash:Vec<hash::ExtrinsicOrHash<Hash>>")]),e._v(")"),n("br"),e._v("\nRemove given extrinsic from the pool and temporarily ban it to prevent\nreimporting.")]),e._v(" "),n("p",[n("strong",[e._v("author_rotateKeys")]),e._v(" ()"),n("br"),e._v("\nGenerate new session keys and returns the corresponding public keys.")]),e._v(" "),n("p",[n("strong",[e._v("author_submitAndWatchExtrinsic")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v("\nsubscriber: Subscriber<TransactionStatus<Hash, BlockHash>>,\n"),n("em",[e._v("bytes: Bytes")]),e._v(") "),n("br"),e._v("\nSubmit an extrinsic to watch. See\n[`TransactionStatus`](sp_transaction_pool::TransactionStatus) for\ndetails on transaction life cycle.")]),e._v(" "),n("p",[n("strong",[e._v("author_submitExtrinsic")]),e._v(" ("),n("em",[e._v("extrinsic: Bytes")]),e._v(") "),n("br"),e._v("\nSubmit hex-encoded extrinsic for inclusion in block.")]),e._v(" "),n("p",[n("strong",[e._v("author_unwatchExtrinsic")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe from extrinsic watching.")]),e._v(" "),n("p",[n("strong",[e._v("babe_epochAuthorship")]),e._v(" () "),n("br"),e._v("\nReturns data about which slots (primary or secondary) can be claimed in\nthe current epoch with the keys in the keystore.")]),e._v(" "),n("p",[n("strong",[e._v("balances_usableBalance")]),e._v(" ("),n("em",[e._v("instance: u8,")]),e._v(" "),n("em",[e._v("who: AccountId")]),e._v(") "),n("br"),e._v("\nNode-specific RPC methods for interaction with balances.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getBlock")]),e._v(" ("),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nGet header and body of a relay chain block.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getBlockHash")]),e._v(" ("),n("em",[e._v("hash:Option<ListOrValue<NumberOrHex>>")]),e._v(") "),n("br"),e._v("\nGet hash of the n-th block in the canon chain. By default returns\nlatest block hash.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getFinalisedHead")]),e._v(" () "),n("br"),e._v("\nGet hash of the last finalized block in the canon chain.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getHead")]),e._v(" ("),n("em",[e._v("hash:Option<ListOrValue<NumberOrHex>>")]),e._v(") "),n("br"),e._v("\nGet hash of the n-th block in the canon chain. By default returns\nlatest block hash.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getHeader")]),e._v(" ("),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nGet header of a relay chain block.")]),e._v(" "),n("p",[n("strong",[e._v("chain_getRuntimeVersion")]),e._v(" ("),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nGet the runtime version.")]),e._v(" "),n("p",[n("strong",[e._v("chain_subscribeAllHeads")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("em",[e._v("subscriber: Subscriber<Header>")]),e._v(") "),n("br"),e._v("\nFinalized head subscription operations.")]),e._v(" "),n("p",[n("strong",[e._v("All head subscription")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<Header>")]),e._v(") "),n("br"),e._v("\nFinalized head subscription operations.")]),e._v(" "),n("p",[n("strong",[e._v("chain_subscribeNewHead")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<Header>")]),e._v(") "),n("br"),e._v("\nFinalized head subscription operations.")]),e._v(" "),n("p",[n("strong",[e._v("chain_subscribeNewHeads")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<Header>")]),e._v(") "),n("br"),e._v("\nFinalized head subscription operations.")]),e._v(" "),n("p",[n("strong",[e._v("chain_subscribeRuntimeVersion")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<RuntimeVersion>")]),e._v(") "),n("br"),e._v("\nUnsubscribe runtime version.")]),e._v(" "),n("p",[n("strong",[e._v("chain_unsubscribeAllHeads")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe all heads.")]),e._v(" "),n("p",[n("strong",[e._v("chain_unsubscribeFinalisedHeads()")]),e._v(" alias "),n("strong",[e._v("chain_unsubscribeAllHeads")])]),e._v(" "),n("p",[n("strong",[e._v("chain_unsubscribeNewHead")]),e._v(" alias "),n("strong",[e._v("chain_unsubscribeAllHeads")])]),e._v(" "),n("p",[n("strong",[e._v("chain_unsubscribeNewHeads")]),e._v(" (metadata: Option<Self::Metadata>, "),n("br"),e._v("\nid: SubscriptionId*)\nUnsubscribe all heads.")]),e._v(" "),n("p",[n("strong",[e._v("chain_unsubscribeRuntimeVersion")]),e._v("("),n("em",[e._v("metadata:Option<Self::Metadata>,")]),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nFinalized head and RuntimeVersion unsubscription operations.")]),e._v(" "),n("p",[n("strong",[e._v("childstate_getKeys")]),e._v(" ("),n("em",[e._v("child_storage_key: PrefixedStorageKey,")]),e._v(" "),n("br"),e._v("\nprefix: StorageKey, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the keys with prefix from a child storage, leave empty to get\nall the keys")]),e._v(" "),n("p",[n("strong",[e._v("childstate_getStorage")]),e._v(" ("),n("em",[e._v("child_storage_key: PrefixedStorageKey,")]),e._v(" "),n("br"),e._v("\nkey: StorageKey, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns a child storage entry at a specific block's state")]),e._v(" "),n("p",[n("strong",[e._v("childstate_getStorageSize")]),e._v(" ("),n("em",[e._v("child_storage_key:\nPrefixedStorageKey,")]),e._v(" "),n("br"),e._v("\nkey: StorageKey, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the size of a child storage entry at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("eth_accounts")]),e._v(" ()* "),n("br"),e._v("\nReturns EVM accounts list.")]),e._v(" "),n("p",[n("strong",[e._v("eth_blockNumber")]),e._v(" () "),n("br"),e._v("\nReturns highest block number from EVM perspective.")]),e._v(" "),n("p",[n("strong",[e._v("eth_call")]),e._v(" ("),n("em",[e._v("_: CallRequest,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Option<BlockNumber>")]),e._v(") "),n("br"),e._v("\nCall contract, returning the output data.")]),e._v(" "),n("p",[n("strong",[e._v("eth_chainId")]),e._v(" () "),n("br"),e._v("\nReturns the chain ID used for transaction signing at the current best\nblock. None is returned if not.")]),e._v(" "),n("p",[n("strong",[e._v("eth_estimateGas")]),e._v(" ("),n("em",[e._v("_: CallRequest,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Option<BlockNumber>")]),e._v(") "),n("br"),e._v("\nEstimate gas needed for execution of given contract.")]),e._v(" "),n("p",[n("strong",[e._v("eth_gasPrice")]),e._v(" () "),n("br"),e._v("\nReturns current gas_price.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getBalance")]),e._v(" ("),n("em",[e._v("_: H160,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Option<BlockNumber>")]),e._v(") "),n("br"),e._v("\nReturns balance of the given account.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getBlockByHash")]),e._v(" ("),n("em",[e._v("_: H256,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: bool")]),e._v(") "),n("br"),e._v("\nReturns block with given hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getBlockByNumber")]),e._v(" ("),n("em",[e._v("_: BlockNumber,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: bool")]),e._v(") "),n("br"),e._v("\nReturns block with given number.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getBlockTransactionCountByHash")]),e._v(" ("),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nReturns the number of transactions in a block with given hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getBlockTransactionCountByNumber")]),e._v(" ("),n("em",[e._v("_: BlockNumber")]),e._v(") "),n("br"),e._v("\nReturns the number of transactions in a block with given block number.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getCode")]),e._v(" ("),n("em",[e._v("_: H160,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Option<BlockNumber>")]),e._v(") "),n("br"),e._v("\nReturns the code at given address at given time (block number).")]),e._v(" "),n("p",[n("strong",[e._v("eth_getLogs")]),e._v(" ("),n("em",[e._v("_: Filter")]),e._v(") "),n("br"),e._v("\nReturns logs matching given filter object.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getStorageAt")]),e._v(" ("),n("em",[e._v("_: H160,")]),e._v(" "),n("br"),e._v("\n_: U256, "),n("br"),e._v(" "),n("em",[e._v("_: Option <BlockNumber>")]),e._v(") "),n("br"),e._v("\nReturns content of the storage at given address.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getTransactionByBlockHashAndIndex")]),e._v(" ( "),n("em",[e._v("_: H256,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Index")]),e._v(") "),n("br"),e._v("\nReturns transaction at given block hash and index.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getTransactionByBlockNumberAndIndex")]),e._v("( "),n("em",[e._v("v_: BlockNumber,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Index")]),e._v(") "),n("br"),e._v("\nReturns transaction by given block number and index.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getTransactionByHash")]),e._v(" ("),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nGet transaction by its hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getTransactionCount")]),e._v(" ("),n("em",[e._v("_: H160,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Option<BlockNumber>")]),e._v(") "),n("br"),e._v("\nReturns the number of transactions sent from given address at given\ntime (block number).")]),e._v(" "),n("p",[n("strong",[e._v("eth_getTransactionReceipt")]),e._v(" ("),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nReturns transaction receipt by transaction hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getUncleByBlockHashAndIndex")]),e._v(" ("),n("em",[e._v("_: H256,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Index")]),e._v(") "),n("br"),e._v("\nReturns Unlce by block hash and index")]),e._v(" "),n("p",[n("strong",[e._v("eth_getUncleByBlockNumberAndIndex")]),e._v(" ("),n("em",[e._v("_: BlockNumber,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: Index")]),e._v(") "),n("br"),e._v("\nReturns an uncle at given block and index.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getUncleCountByBlockHash")]),e._v(" ("),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nReturns the number of uncles in a block with given hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getUncleCountByBlockNumber")]),e._v(" ("),n("em",[e._v("_: BlockNumber")]),e._v(") "),n("br"),e._v("\nReturns the number of uncles in a block with given block number.")]),e._v(" "),n("p",[n("strong",[e._v("eth_getWork")]),e._v(" ()* "),n("br"),e._v("\nReturns the hash of the current block, the seedHash, and the boundary\ncondition to be met.")]),e._v(" "),n("p",[n("strong",[e._v("eth_hashrate")]),e._v(" () "),n("br"),e._v("\nReturns the number of hashes per second that the node is mining with.")]),e._v(" "),n("p",[n("strong",[e._v("eth_mining")]),e._v(" () "),n("br"),e._v("\nReturns true if client is actively mining new blocks.")]),e._v(" "),n("p",[n("strong",[e._v("eth_protocolVersion")]),e._v(" () "),n("br"),e._v("\nReturns protocol version encoded as a string (quotes are necessary\nhere).")]),e._v(" "),n("p",[n("strong",[e._v("eth_sendRawTransaction")]),e._v(" ("),n("em",[e._v("_: Bytes")]),e._v(") "),n("br"),e._v("\nSends signed transaction, returning its hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_sendTransaction")]),e._v(" ("),n("em",[e._v("_: TransactionRequest")]),e._v(") "),n("br"),e._v("\nSends transaction; will block waiting for signer to return the\ntransaction hash.")]),e._v(" "),n("p",[n("strong",[e._v("eth_submitHashrate")]),e._v(" ("),n("em",[e._v("_: U256,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nUsed for submitting mining hashrate.")]),e._v(" "),n("p",[n("strong",[e._v("eth_submitWork")]),e._v(" ( "),n("em",[e._v("_: H64,")]),e._v(" "),n("br"),e._v("\n_: H256, "),n("br"),e._v(" "),n("em",[e._v("_: H256")]),e._v(") "),n("br"),e._v("\nUsed for submitting a proof-of-work solution.")]),e._v(" "),n("p",[n("strong",[e._v("eth_subscribe")]),e._v(" ("),n("em",[e._v("_: Self::Metadata,")]),e._v(" "),n("br"),e._v("\n_: typed::Subscriber<pubsub::Result>, "),n("br"),e._v("\n_: pubsub::Kind, "),n("br"),e._v(" "),n("em",[e._v("_: Option<pubsub::Params>")]),e._v(") "),n("br"),e._v("\nSubscribe to Eth subscription.")]),e._v(" "),n("p",[n("strong",[e._v("eth_syncing")]),e._v(" () "),n("br"),e._v("\nReturns an object with data about the sync status or false.")]),e._v(" "),n("p",[n("strong",[e._v("eth_unsubscribe")]),e._v(" ("),n("em",[e._v("_: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("_: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe from existing Eth subscription.")]),e._v(" "),n("p",[n("strong",[e._v("grandpa_proveFinality")]),e._v(" ( "),n("em",[e._v("begin: Hash,")]),e._v(" "),n("br"),e._v("\nend: Hash, "),n("br"),e._v(" "),n("em",[e._v("authorities_set_id: u64")]),e._v(") "),n("br"),e._v("\nProve finality for the given block number by returning the\njustification for the last block in the set and all the intermediary\nheaders to link them together.")]),e._v(" "),n("p",[n("strong",[e._v("grandpa_roundState")]),e._v(" () "),n("br"),e._v("\nReturns the state of the current best round state as well as the\nongoing background rounds.")]),e._v(" "),n("p",[n("strong",[e._v("grandpa_subscribeJustifications")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<Notification>")]),e._v(") "),n("br"),e._v("\nReturns the block most recently finalized by Grandpa, alongside side\nits justification.")]),e._v(" "),n("p",[n("strong",[e._v("grandpa_unsubscribeJustifications")]),e._v(" ("),n("em",[e._v("metadata: "),n("br"),e._v("\nOption<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe from receiving notifications about recently finalized\nblocks.")]),e._v(" "),n("p",[n("strong",[e._v("headerMMR_genProof")]),e._v(" ("),n("em",[e._v("block_number_of_member_leaf: u64,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("block_number_of_last_leaf: u64")]),e._v(") "),n("br"),e._v("\nGet the MMR proof for a certain height, block number of member leaf,\nblock number of the lastest leafnet_listening,\nReturns true if client is actively listening for network connections.\nOtherwise false.")]),e._v(" "),n("p",[n("strong",[e._v("net_peerCount")]),e._v(" () =\nReturns number of peers connected to node.")]),e._v(" "),n("p",[n("strong",[e._v("net_version")]),e._v(" () "),n("br"),e._v("\nReturns protocol version.")]),e._v(" "),n("p",[n("strong",[e._v("offchain_localStorageGet")]),e._v(" ("),n("em",[e._v("kind: StorageKind,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("key: Bytes")]),e._v(") "),n("br"),e._v("\nGet offchain local storage under given key and prefix.")]),e._v(" "),n("p",[n("strong",[e._v("offchain_localStorageSet")]),e._v(" ("),n("em",[e._v("kind: StorageKind,")]),e._v(" "),n("br"),e._v("\nkey: Bytes, "),n("br"),e._v(" "),n("em",[e._v("value: Bytes")]),e._v(") "),n("br"),e._v("\nSet offchain local storage under given key and prefix.")]),e._v(" "),n("p",[n("strong",[e._v("payment_queryFeeDetails")]),e._v(" ("),n("em",[e._v("encoded_xt: Bytes,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("at: Option<BlockHash>")]),e._v(") "),n("br"),e._v("\nQuery the fee of a payment")]),e._v(" "),n("p",[n("strong",[e._v("payment_queryInfo")]),e._v(" ("),n("em",[e._v("encoded_xt: Bytes,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("at: Option<BlockHash>")]),e._v(") "),n("br"),e._v("\nGet details regarding payment fee.")]),e._v(" "),n("p",[n("strong",[e._v("staking_powerOf")]),e._v(" ("),n("em",[e._v("who: AccountId")]),e._v(") "),n("br"),e._v("\nRetrunt the power on a certain AccountId in a staking context.")]),e._v(" "),n("p",[n("strong",[e._v("state_call")]),e._v(" ("),n("em",[e._v("name: String,")]),e._v(" "),n("br"),e._v("\nbytes: Bytes, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nCall a contract's block state")]),e._v(" "),n("p",[n("strong",[e._v("state_callAt")]),e._v(" ("),n("em",[e._v("name: String,")]),e._v(" "),n("br"),e._v("\nbytes: Bytes, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nCall a contract at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getKeys")]),e._v(" ("),n("em",[e._v("prefix: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the keys with prefix, leave empty to get all the keys.")]),e._v(" "),n("p",[n("strong",[e._v("state_getKeysPaged")]),e._v(" ("),n("em",[e._v("prefix: Option<StorageKey>,")]),e._v(" "),n("br"),e._v("\ncount: u32, "),n("br"),e._v("\nstart_key: Option<StorageKey>, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the keys with prefix with pagination support.\nUp to `count` keys will be returned.\nIf `start_key` is passed, return next keys in storage in\nlexicographic order.")]),e._v(" "),n("p",[n("strong",[e._v("state_getKeysPagedAt")]),e._v(" ("),n("em",[e._v("prefix: Option<StorageKey>,")]),e._v(" "),n("br"),e._v("\ncount: u32, "),n("br"),e._v("\nstart_key: Option<StorageKey>, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the keys with prefix with pagination support.\nUp to `count` keys will be returned.\nIf `start_key` is passed, return next keys in storage in\nlexicographic order.")]),e._v(" "),n("p",[n("strong",[e._v("state_getMetadata")]),e._v(" () "),n("br"),e._v("\nReturns the runtime metadata as an opaque blob.state_getPairs,\nReturns the keys with prefix, leave empty to get all the keys")]),e._v(" "),n("p",[n("strong",[e._v("state_getReadProof")]),e._v(" ("),n("em",[e._v("keys: Vec<StorageKey>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns proof of storage entries at a specific block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getRuntimeVersion")]),e._v(" ("),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nGet the runtime version.")]),e._v(" "),n("p",[n("strong",[e._v("state_getStorage")]),e._v(" ("),n("em",[e._v("key: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns a storage entry at a specific block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getStorageAt")]),e._v(" ("),n("em",[e._v("key: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash")]),e._v(">) "),n("br"),e._v("\nReturns the hash of a storage entry at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getStorageHash")]),e._v(" ("),n("em",[e._v("key: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nReturns the hash of a storage entry at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getStorageHashAt")]),e._v(" ("),n("em",[e._v("key: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash")]),e._v(">) "),n("br"),e._v("\nReturns the hash of a storage entry at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_getStorageSize")]),e._v(" ("),n("em",[e._v("key: StorageKey,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash")]),e._v(") "),n("br"),e._v("\nReturns the size of a storage entry at a block's state.")]),e._v(" "),n("p",[n("strong",[e._v("state_queryStorage")]),e._v(" ("),n("em",[e._v("keys: Vec<StorageKey>,")]),e._v(" "),n("br"),e._v("\nblock: Hash, "),n("br"),e._v(" "),n("em",[e._v("hash: Option<Hash>")]),e._v(") "),n("br"),e._v("\nQuery historical storage entries (by key) starting from a block given as\nthe second parameter.\nNOTE: This first returned result contains the initial state of storage\nfor all keys.\nSubsequent values in the vector represent changes to the previous state\n(diffs).")]),e._v(" "),n("p",[n("strong",[e._v("state_queryStorageAt")]),e._v(" ("),n("em",[e._v("keys: Vec<StorageKey>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("at: Option<Hash>")]),e._v(") "),n("br"),e._v("\nQuery storage entries (by key) starting at block hash given as the\nsecond parameter.")]),e._v(" "),n("p",[n("strong",[e._v("state_subscribeRuntimeVersion")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("subscriber: Subscriber<RuntimeVersion")]),e._v(") "),n("br"),e._v("\nNew runtime version subscription.")]),e._v(" "),n("p",[n("strong",[e._v("state_subscribeStorage")]),e._v(" ("),n("em",[e._v("metadata: Self::Metadata,")]),e._v(" "),n("br"),e._v("\nsubscriber: Subscriber<StorageChangeSet<Hash>>, "),n("br"),e._v(" "),n("em",[e._v("keys: Option<Vec<StorageKey>")]),e._v(") "),n("br"),e._v("\nNew storage subscription.")]),e._v(" "),n("p",[n("strong",[e._v("state_unsubscribeRuntimeVersion")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe from runtime subscription")]),e._v(" "),n("p",[n("strong",[e._v("state_unsubscribeStorage")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nUnsubscribe from storage subscription")]),e._v(" "),n("p",[n("strong",[e._v("subscribe_newHead")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(") "),n("br"),e._v("\nNew head subscription")]),e._v(" "),n("p",[n("strong",[e._v("sync_state_genSyncSpec")]),e._v(" ("),n("em",[e._v("raw: bool")]),e._v(") "),n("br"),e._v("\nReturns the json-serialized chainspec running the node, with a sync\nstate.")]),e._v(" "),n("p",[n("strong",[e._v("system_accountNextIndex")]),e._v(" ("),n("em",[e._v("account: AccountId")]),e._v(") "),n("br"),e._v("\nReturns the next valid index (aka nonce) for given account. This method\ntakes into consideration all pending transactions currently in the pool\nand if no transactions are found in the pool it fallbacks to query the\nindex from the runtime (aka. state nonce).")]),e._v(" "),n("p",[n("strong",[e._v("system_addLogFilter")]),e._v(" ("),n("em",[e._v("directives: String")]),e._v(") "),n("br"),e._v("\nAdds the supplied directives to the current log filter. The syntax is\nidentical to the CLI `<target>=<level>`:`sync=debug,state=trace`")]),e._v(" "),n("p",[n("strong",[e._v("system_addReservedPeer")]),e._v(" (peer: String) "),n("br"),e._v("\nAdds a reserved peer. Returns the empty string or an error. The string\nparameter should encode a `p2p` multiaddr.")]),e._v(" "),n("p",[n("strong",[e._v("system_chain")]),e._v(" () "),n("br"),e._v("\nGet the chain's name. Given as a string identifier.")]),e._v(" "),n("p",[n("strong",[e._v("system_chainType")]),e._v(" () "),n("br"),e._v("\nGet the chain's type.")]),e._v(" "),n("p",[n("strong",[e._v("system_dryRun")]),e._v(" ("),n("em",[e._v("extrinsic: Bytes")]),e._v(", "),n("br"),e._v("\nat: Option<BlockHash>*) "),n("br"),e._v("\nDry run an extrinsic at a given block. Return SCALE encoded\nApplyExtrinsicResult.")]),e._v(" "),n("p",[n("strong",[e._v("system_dryRunAt")]),e._v(" ("),n("em",[e._v("extrinsic: Bytes,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("at: Option<BlockHash>")]),e._v(") "),n("br"),e._v("\nDry run an extrinsic at a given block. Return SCALE encoded\nApplyExtrinsicResult")]),e._v(" "),n("p",[n("strong",[e._v("system_health")]),e._v(" () "),n("br"),e._v("\nReturn health status of the node. Node is considered healthy if it is:")]),e._v(" "),n("ul",[n("li",[e._v("connected to some peers (unless running in dev mode)")]),e._v(" "),n("li",[e._v("not performing a major sync")])]),e._v(" "),n("p",[n("strong",[e._v("system_localListenAddresses")]),e._v(" () "),n("br"),e._v("\nReturns the multiaddresses that the local node is listening on. The\naddresses include a trailing `/p2p/` with the local PeerId, and are\nthus suitable to be passed to `system_addReservedPeer` or as a\nbootnode address for example.")]),e._v(" "),n("p",[n("strong",[e._v("system_localPeerId")]),e._v(" () "),n("br"),e._v("\nReturns the base58-encoded PeerId of the node.")]),e._v(" "),n("p",[n("strong",[e._v("system_name")]),e._v(" () "),n("br"),e._v("\nGet the node's implementation name. Plain old string.")]),e._v(" "),n("p",[n("strong",[e._v("system_networkState")]),e._v(" () "),n("br"),e._v("\nReturn the current network state")]),e._v(" "),n("p",[n("strong",[e._v("system_nodeRoles")]),e._v(" () "),n("br"),e._v("\nReturns the roles the node is running as.")]),e._v(" "),n("p",[n("strong",[e._v("system_peers")]),e._v(" () "),n("br"),e._v("\nReturns currently connected peers")]),e._v(" "),n("p",[n("strong",[e._v("system_properties")]),e._v(" () "),n("br"),e._v("\nGet a custom set of properties as a JSON object, defined in the chain\nspec.")]),e._v(" "),n("p",[n("strong",[e._v("system_removeReservedPeer")]),e._v(" ("),n("em",[e._v("peer_id: String")]),e._v(") "),n("br"),e._v("\nRemove a reserved peer. Returns the empty string or an error. The\nstring should encode only the PeerId.")]),e._v(" "),n("p",[n("strong",[e._v("system_resetLogFilter")]),e._v(" () "),n("br"),e._v("\nResets the log filter to defaults.")]),e._v(" "),n("p",[n("strong",[e._v("system_syncState")]),e._v("() "),n("br"),e._v("\nReturns the state of the syncing of the node: starting block, current\nbest block, highest known block.")]),e._v(" "),n("p",[n("strong",[e._v("system_version")]),e._v("() "),n("br"),e._v("\nGet the node implementation's version. Should be a semver string.")]),e._v(" "),n("p",[n("strong",[e._v("unsubscribe_newHead")]),e._v(" ("),n("em",[e._v("metadata: Option<Self::Metadata>,")]),e._v(" "),n("br"),e._v(" "),n("em",[e._v("id: SubscriptionId")]),e._v(")")]),e._v(" "),n("p",[n("strong",[e._v("web3_clientVersion")]),e._v(" () "),n("br"),e._v("\nReturns current client version.")]),e._v(" "),n("p",[n("strong",[e._v("web3_sha3")]),e._v(" ("),n("em",[e._v("_: Bytes")]),e._v(") "),n("br"),e._v("\nReturns sha3 of the given data.")])])}),[],!1,null,null,null);t.default=_.exports}}]);